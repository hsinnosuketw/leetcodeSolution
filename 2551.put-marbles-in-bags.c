/*
 * @lc app=leetcode id=2551 lang=c
 *
 * [2551] Put Marbles in Bags
 *
 * https://leetcode.com/problems/put-marbles-in-bags/description/
 *
 * algorithms
 * Hard (65.85%)
 * Likes:    2458
 * Dislikes: 108
 * Total Accepted:    113.6K
 * Total Submissions: 159.3K
 * Testcase Example:  '[1,3,5,1]\n2'
 *
 * You have k bags. You are given a 0-indexed integer array weights where
 * weights[i] is the weight of the i^th marble. You are also given the integer
 * k.
 *
 * Divide the marbles into the k bags according to the following rules:
 *
 *
 * No bag is empty.
 * If the i^th marble and j^th marble are in a bag, then all marbles with an
 * index between the i^th and j^th indices should also be in that same bag.
 * If a bag consists of all the marbles with an index from i to j inclusively,
 * then the cost of the bag is weights[i] + weights[j].
 *
 *
 * The score after distributing the marbles is the sum of the costs of all the
 * k bags.
 *
 * Return the difference between the maximum and minimum scores among marble
 * distributions.
 *
 *
 * Example 1:
 *
 *
 * Input: weights = [1,3,5,1], k = 2
 * Output: 4
 * Explanation:
 * The distribution [1],[3,5,1] results in the minimal score of (1+1) + (3+1) =
 * 6.
 * The distribution [1,3],[5,1], results in the maximal score of (1+3) + (5+1)
 * = 10.
 * Thus, we return their difference 10 - 6 = 4.
 *
 *
 * Example 2:
 *
 *
 * Input: weights = [1, 3], k = 2
 * Output: 0
 * Explanation: The only distribution possible is [1],[3].
 * Since both the maximal and minimal score are the same, we return 0.
 *
 *
 *
 * Constraints:
 *
 *
 * 1 <= k <= weights.length <= 10^5
 * 1 <= weights[i] <= 10^9
 *
 *
 */

// @lc code=start
#include <stdlib.h>
int comp(const void *a, const void *b)
{
    return *(int *)a - *(int *)b;
}

long long putMarbles(int *weights, int weightsSize, int k)
{
    /*
    1. k bags mean k - 1 splitting points
    2. Each splitting point will generate the head and tail of two bags
    3. The number candidate splitting points will be weightsSize - 1
    4. The maximum score will be generated by selecting  k - 1 largest splitting points from weightsSize - 1
    5. Same for the minimum score
    */
    long long ans = 0;
    int *splittingPoints = (int *)malloc(sizeof(int) * (weightsSize - 1));

    for (int i = 0; i < weightsSize - 1; i++)
    {
        splittingPoints[i] = weights[i] + weights[i + 1];
    }

    qsort(splittingPoints, weightsSize - 1, sizeof(int), comp);
    for (int i = 0; i < k - 1; i++)
    {
        ans += splittingPoints[weightsSize - 2 - i] - splittingPoints[i];
    }

    free(splittingPoints);
    return ans;
}
// @lc code=end
